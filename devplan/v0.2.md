# Development Plan — v0.2

In-progress milestones for kiso v0.2. Continues from v0.1 (all M1–M43 complete).

**Completed**: M44–M71 | **In progress**: M72

## Principles

- **Agile**: smallest testable increment first, then layer on
- **No dead code**: every line written is immediately reachable and testable
- **Fail loud**: missing config, broken provider, invalid input → clear error, never silent fallback
- **Tested**: every milestone adds tests. `uv run pytest` must pass before moving on.

---

## Milestone 44: Deferred items + polish

Collect all items explicitly deferred during v0.1 development, plus small UX fixes observed in production.

### 44a. worker — extract `search.py` from `loop.py`

**Problem**: M36 planned `kiso/worker/search.py` as a dedicated module for the search handler (analogous to `exec.py` and `skill.py`). The logic instead stayed in `loop.py`, breaking the package's symmetry. `__init__.py` exports nothing search-related.

**Fix**: extract the search handler from `loop.py` into `kiso/worker/search.py`, analogously to `exec.py` and `skill.py`. Update `__init__.py` and imports.

- [x] `kiso/worker/search.py`: new module with `_parse_search_args()` and `_search_task()` extracted from `loop.py`
- [x] `kiso/worker/loop.py`: removed inline args parsing and direct `run_searcher` call; uses `_search_task()`
- [x] `kiso/worker/__init__.py`: exports `_parse_search_args` and `_search_task`
- [x] `tests/test_worker.py`: updated patch targets from `kiso.worker.loop.run_searcher` to `kiso.worker.search.run_searcher` (17 occurrences)
- [x] `tests/test_search.py`: 33 isolated unit tests for `_parse_search_args` and `_search_task` (boundary max_results, type errors, malformed JSON, warning log, parameter propagation)

---

### 44b. CLI — loader on new line

**Problem**: the "thinking..." spinner appears inline with the last content line instead of on its own line. Visually confusing when the previous output ends without a trailing newline.

**Fix**: ensure the loader/spinner always starts on a fresh line.

- [x] `cli/__init__.py`: `_poll_status` gains `_at_col0: bool = True` parameter; emits `\n` before first frame when `_at_col0=False`
- [x] tests: 2 new cases verify `\n\n\r` (extra newline) vs `\n\r` (no extra newline)

---

### 44c. Fact poisoning — `save_learning` content filter

**Context**: during M21 the curator prompt was deemed sufficient to guard against manipulative learnings. Monitor in production whether this holds or whether pre-storage filtering is needed.

- [x] Added `_SENSITIVE_PATTERN` regex + filter in `save_learning()` (keywords: password/passwd/token, hex ≥32 chars); returns 0 + logs warning
- [x] 7 unit tests: keyword rejection (case-insensitive), hex threshold, benign acceptance, sentinel preservation

---

### 44d. Verbose mode — incremental LLM rendering

**Context**: `append_task_llm_call()` was added in M31 but the worker still batches all LLM call data at task end. Documented as known limitation in `docs/cli.md`.

**Fix**: call `append_task_llm_call()` after each individual LLM call (searcher, exec translator, reviewer, messenger) so verbose panels appear incrementally during task execution.

- [x] `kiso/worker/loop.py`: `_append_calls()` helper added; called after each LLM op (translator, reviewer, messenger, searcher) in all task branches and fast-path
- [x] `llm_calls=` removed from all `update_task_usage` call sites; `_KEEP_LLM_CALLS` sentinel preserves incrementally-appended column
- [x] `docs/cli.md`: removed "Known limitations — batch rendering" note
- [x] 5 tests: assert `_append_calls` call count per task type; verify `update_task_usage` called without explicit `llm_calls`

---

### 44e. Post-review hardening — M44b/M44c/M44d follow-up

High and medium severity issues identified during review of M44b+M44d.

#### High severity

- [x] `cli/__init__.py`: full docstring for `_poll_status()` explaining the `_at_col0` parameter
- [x] `kiso/store.py`: `save_learning()` — TypeError on `content=None`; return 0 on empty/whitespace string; updated docstring
- [x] `kiso/worker/loop.py`: `_append_calls()` — `try/except Exception` with log.warning; no worker crash on usage tracking errors
- [x] `kiso/worker/loop.py`: `_fast_path_chat()` — `_append_calls()` also called in the failure path (messenger exception)

#### Medium severity

- [x] `tests/test_store.py`: guard None (TypeError), empty string, whitespace, boundary hex 31 chars (accepted) vs 32 chars (rejected)
- [x] `tests/test_worker.py`: `_append_calls` handles exception, fast_path failure appends, success vs failure same call_count; retry scenario verifies 5 `_append_calls` (2 attempts × 2 + 1 msg)
- [x] `tests/test_cli.py`: `\n\n\r` appears exactly once — extra newline only on first frame, not subsequent frames

---

### 44f. Admin context — session labels on facts

**Context**: M43 implemented strict session scoping for regular users (Option B). Admin users already bypass the filter and receive all facts, but with no indication of which session each fact originated from, making cross-session facts indistinguishable in the planner context.

**Fix**: when building planner context for an admin caller, split facts into two priority tiers:
- **Primary** (`## Known Facts`): facts from the current session + global facts (session IS NULL). Shown without session label — these are the most relevant.
- **Background** (`## Context from Other Sessions`): facts from other sessions, annotated with `[session:<name>]`. Available as broader memory if needed.

Non-admin path is unchanged (single `## Known Facts` block, no labels).

- [x] `kiso/brain.py`: `build_planner_messages()` — admin path splits `facts` into `primary` and `other`; `_group_by_category()` helper renders both blocks; non-admin uses `primary=facts, other=[]`
- [x] `tests/test_brain.py`: `test_admin_facts_hierarchy` — current-session + global facts in `## Known Facts` (no label); other-session fact in `## Context from Other Sessions` with `[session:name]`; current-session fact never carries a label
- [x] `tests/test_brain.py`: `test_non_admin_facts_no_session_labels` — non-admin context has no `[session:` and no `## Context from Other Sessions`

---

## Milestone 45: Planner — plugin discovery via registry (not web search)

**Problem observed in production**: the user asks "I want to install the discord connector" and the planner emits `[search] kiso discord connector` (web search) instead of `[exec] curl <registry_url>`. The reviewer correctly rejects the result ("sa-mp discord connector", not kiso's), but the cycle is wasted.

**Root causes**:
1. The rule "Prefer search over exec curl/wget for web lookups" in the `search` task type had no explicit exception for the kiso registry.
2. The MANDATORY rules on registry-based discovery were buried at the end and didn't explicitly link the exception to the search rule.
3. `kiso` was not in `PROBE_BINARIES` → didn't appear in the "available binaries" list in System Environment.

**Fix**:

- [x] `kiso/roles/planner.md`: added explicit exception in the `search` task description: "NEVER use search to discover kiso plugins — use exec curl on the registry URL instead (see Plugin installation rule below)"
- [x] `kiso/roles/planner.md`: MANDATORY rules unified and rewritten as "Plugin installation (MANDATORY)": single block covering discovery (exec curl registry, never web search) + install + env requirements
- [x] `kiso/sysenv.py`: added `"kiso"` at the head of `PROBE_BINARIES` — the binary appears in "available binaries" if installed, making its availability explicit to the planner
- [x] `tests/test_brain.py`: `test_m45_plugin_install_uses_registry_not_search` — verifies the prompt contains "NEVER" + "registry" + "web search"
- [x] `tests/test_brain.py`: `test_m45_plugin_install_rule_is_mandatory` — verifies "Plugin installation (MANDATORY)" is in the prompt
- [x] `tests/test_sysenv.py`: `test_kiso_in_probe_list` — verifies `"kiso"` is in `PROBE_BINARIES`
- [x] `docs/flow.md`: updated sections "Facts" (was "global", now "session-scoped"), "Planner Context" (added admin example with `## Context from Other Sessions`)
- [x] `docs/security-risks.md`: updated two stale sections ("Facts are global" → M43 scoping + residual risk for global categories)
- [x] `docs/llm-roles.md`: updated context table ("Facts (global)" → "Facts (session-scoped; admin sees all)")

---

## Milestone 47: Planner/Reviewer — plan quality and evaluation correctness

Problems observed in production during the Discord installation. Three distinct bugs that chained together causing a needless replan loop until timeout.

---

### 47a. Planner — self-awareness and intent disambiguation

**Problem**: the planner doesn't know it's the brain of a specific system (Kiso). It behaves as a generic OS-level task planner. This causes two cascading bugs: (1) it doesn't distinguish between requests targeting the OS layer and those targeting the Kiso layer; (2) it has a bias toward execution even when intent is ambiguous.

**Root cause**: the prompt starts with "You are a task planner." — no identity, no Kiso context, no awareness of the two available layers.

**Agreed solution — two prompt interventions**:

**(1) Self-awareness** — add at the top of the prompt:
- Identity: the planner is Kiso's brain, not a generic planner
- Two-layer awareness: it has both OS commands and native Kiso primitives (skill, connector, env, memory) at its disposal; before planning an OS-level solution, check if a Kiso-native solution already exists. Scoped to solution choice, not as an absolute global preference.

**(2) Disambiguation bias** — invert the default on clarification:
- Current (permissive): "if unclear, ask" — the planner must justify asking
- New (restrictive): proceed only if both intent AND target are unambiguous; otherwise ask
- Single line, no enumerated cases; two-layer awareness provides the context that makes the rule applicable

- [x] `kiso/roles/planner.md`: added Kiso identity + two-layer awareness at the top of the prompt
- [x] `kiso/roles/planner.md`: clarification rule inverted — "proceed only if unambiguous, else ask"
- [x] `kiso/roles/planner.md`: guidance on task-scoped `expect`
- [x] `docs/llm-roles.md`: "Identity and Environment Awareness" section added to Planner
- [x] `docs/llm-roles.md`: `expect` field updated with note on task scope
- [x] `tests/test_brain.py`: `TestM47PlannerIdentityAndTwoLayer` — 5 tests on identity, two-layer, Kiso-native preference, clarification bias, expect scoping

---

### 47b. Reviewer — evaluate task `expect`, not plan goal

**Problem**: the reviewer uses the Plan Goal as success criterion instead of the individual task's `expect`. Concrete case: `apt-get install -f` with output "0 upgraded, 0 installed" (= no broken dependencies = success) was marked `replan` because "Discord is not yet fully functional" — which is the plan goal, not the task criterion.

**Root cause**: the reviewer prompt receives the `Plan Goal` as context but doesn't explicitly distinguish between "context" and "success criterion". The model tends to merge them.

**Agreed solution — two interventions**:

1. **Rename** the `Plan Goal` field → `Plan Context` in the message built by `build_reviewer_messages` in `brain.py`. The name changes the frame at a structural level: the model sees data consistent with the rule rather than data that contradicts it.

2. **Add a rule** to the reviewer prompt: "Plan Context is background only. The sole success criterion is the task's `expect`." Output "nothing to do" / "0 changes" for maintenance commands is valid success if consistent with `expect`.

- [x] `kiso/brain.py`: `build_reviewer_messages` — renamed `## Plan Goal` → `## Plan Context`
- [x] `kiso/roles/reviewer.md`: added rule "Plan Goal is background context only" + rule on "0 changes"
- [x] `docs/llm-roles.md`: context table updated ("Plan context (goal) — as background"); `goal` output field updated
- [x] `tests/test_brain.py`: `TestM47ReviewerPlanContext` — 4 tests on label, background rule, sole criterion, zero-changes

---

### 47c. Planner — `expect` scoped to task, not plan

**Problem**: the planner writes `expect` fields describing the plan's global goal instead of the expected output of the individual task. Example: for `apt-get install -f`, the planner wrote `"All dependencies resolved, Discord should be fully functional"` — which is the plan goal. This causes problem 47b.

**Root cause**: no instructions in the planner prompt on how to write task-scoped `expect`. The planner propagates the plan goal into each task's `expect` instead of describing what that specific task must produce/show.

**Note**: 47c is independent of 47b and necessary even after the reviewer fix. A correctly calibrated reviewer that ignores Plan Context still evaluates `expect` literally — if `expect` says "Discord should be fully functional", the reviewer is forced to mark `apt-get install -f` as failed even if that's wrong. The problem is upstream: the planner wrote the wrong `expect`.

**Agreed solution**: add explicit guidance to the planner prompt on how to write `expect`:
- describes the direct output of this specific task, not the plan goal
- must be falsifiable from the task output alone
- for maintenance/cleanup commands (apt-get install -f, git clean, etc.), "0 changes" is valid success and should be stated explicitly in `expect`

- [x] implemented together with 47a (`kiso/roles/planner.md` + test `test_planner_prompt_expect_scoping`)

---

### 47d. Worker (exec translator) — retry hint ignored

**Problem**: on retry, the worker ignores the hint in the Retry Context and re-translates the original task `detail` literally, producing the same failed command. In the Discord case, the hint said "use `apt install discord`" but the worker reproduced `apt-get install -f` because the task `detail` specified it.

**Root cause**: the worker prompt doesn't mention the Retry Context. The worker doesn't know that in case of retry, the hint should guide the alternative translation.

**Agreed solution**: add to the worker prompt that when a Retry Context with a hint is present, the hint takes priority over literal translation of `detail`. The `detail` remains context for understanding the task, but the hint guides the command to produce.

- [x] `kiso/roles/worker.md`: added rule on hint priority
- [x] `docs/llm-roles.md`: rule added in "Rules in the Default Prompt" for the exec translator
- [x] `tests/test_brain.py`: `TestM47WorkerHintPriority` — test on presence of rule in prompt

---

## Milestone 48: Prompt hygiene — cross-cutting optimizations to role prompts

Optimizations identified from systematic review of all role prompts. No new behavior: only coherence, redundancy reduction, and filling instruction gaps that the model currently resolves by inference (with variable results).

---

### 48a. Reviewer — "You receive" inconsistent with actual message

**Problem**: the prompt describes "You receive: The plan goal" but since M47 the message arrives labeled `## Plan Context`. The model sees a label different from what the prompt describes — structural inconsistency.

**Fix**: align the prompt description to `Plan Context`.

- [x] `kiso/roles/reviewer.md`: "You receive: The plan goal" → "The plan context"
- [x] `tests/test_brain.py`: `TestM48ReviewerPromptHygiene` — test_48a_you_receive_says_plan_context, test_48a_no_plan_goal_in_receive_block

---

### 48b. Reviewer — exit code not used in rules

**Problem**: the reviewer receives `## Command Status` (succeeded/FAILED exit code) but no rule says how to use it. The model interprets it autonomously. In ambiguous cases (output looks OK but exit code 1, or stderr with exit code 0) it can go the wrong way without explicit instructions.

**Fix**: add explicit rule: non-zero exit code is a strong signal of failure even if output looks partially OK; exit code 0 is not sufficient alone if output doesn't satisfy `expect`.

- [x] `kiso/roles/reviewer.md`: added rule "Exit code is a strong signal: non-zero = strong failure indicator; zero = necessary but not sufficient"
- [x] `tests/test_brain.py`: `TestM48ReviewerPromptHygiene` — test_48b_exit_code_rule_present, test_48b_nonzero_is_failure_signal, test_48b_zero_not_sufficient_alone

---

### 48c. Planner — `expect` and `detail` rules fragmented

**Problem**: two pairs of conceptually identical rules are split and separated in the prompt:
1. Line 21 (`expect non-null`) + line 28 (`expect task-scoped`) — same rule in two pieces
2. Line 26 (`detail self-contained`) + line 46 (`detail specific, include commands/paths`) — same instruction repeated; the second (more important) arrives last and gets less attention

**Fix**: merge each pair into a single rule, moved to a relevant position. Reduces total prompt text.

- [x] `kiso/roles/planner.md`: expect rule unified (non-null + task-scoped in one line); detail rule unified (self-contained + specific + commands/paths in one line); removed redundant line "exec task detail must be specific"
- [x] `tests/test_brain.py`: `TestM48PlannerMergedRules` — 6 tests on presence of unified rules and absence of duplicates

---

### 48d. Curator — no category in promote

**Problem**: the curator promotes facts as free text without indicating the category (project/user/tool/general). The information is lost and the consolidator must infer it. If the curator already distinguished the type of fact, subsequent categorization would be more reliable.

**Fix**: add `category` field to the curator's JSON output. `_apply_curator_result` uses the category to determine session scoping: only `"user"` is session-scoped, others are global. Bug fix: non-user facts must no longer be saved with `session=session`.

- [x] `kiso/roles/curator.md`: added category instruction for promote (project/user/tool/general)
- [x] `kiso/brain.py`: `CURATOR_SCHEMA` — added nullable `category` field with enum; added to `required`
- [x] `kiso/brain.py`: `validate_curator` — optional validation: if category != null, must be a valid value
- [x] `kiso/worker/loop.py`: `_apply_curator_result` — uses `ev.get("category") or "general"`; session=session only if category=="user", otherwise session=None
- [x] `tests/test_brain.py`: `TestM48CuratorCategoryField` — 11 tests on prompt, schema, validate_curator
- [x] `tests/test_worker.py`: `TestM48ApplyCuratorCategory` — 9 tests on session scoping per category

---

### 48e. Summarizer-facts — no tiebreaker for contradictions

**Problem**: the prompt says "remove contradictory items" but doesn't specify which to keep when two facts contradict each other. The model chooses arbitrarily.

**Fix**: add explicit resolution criterion: on contradiction, prefer the fact with higher confidence; if equal, prefer the more specific one.

- [x] `kiso/roles/summarizer-facts.md`: added tiebreaker rule (higher confidence wins; if equal, more specific wins)
- [x] `tests/test_brain.py`: `TestM48SummarizerFactsTiebreaker` — 3 tests on presence of tiebreaker rule

---

### 48f. Worker (exec translator) — no rule on sudo

**Problem**: no instructions on `sudo`. In non-root environments, the planner can write task details that imply elevated privileges, and the worker adds `sudo` autonomously or doesn't — non-deterministic behavior.

**Fix**: add rule: do not add `sudo` unless explicitly mentioned in the task detail or in the system environment.

- [x] `kiso/roles/worker.md`: added rule "Do NOT add sudo unless explicitly mentioned"
- [x] `tests/test_brain.py`: `TestM48WorkerNoSudo` — 3 tests on presence of no-sudo rule
- [x] `docs/llm-roles.md`: updated sections Reviewer (exit code rule), Exec Translator (no-sudo), Curator (schema with category, verdicts), Summarizer-facts (tiebreaker)

---

## Milestone 49: Versioning — version file + `kiso version` command

**Problem**: the project version was implicit (only in `pyproject.toml`). There was no canonical file to use as reference when writing the version in docs/devplan, nor a CLI command to print it.

**Fix**: single `kiso/_version.py` file as source of truth + `kiso version` command + `--version/-V` flag.

- [x] `kiso/_version.py`: `__version__ = "0.1.0"` — single source of truth for the version
- [x] `cli/__init__.py`: imports `__version__`; adds `-V/--version` flag (argparse built-in); adds `version` subcommand that prints `kiso {__version__}`; parser description includes the version
- [x] `tests/test_cli.py`: `TestVersionFile` (3 tests: file exists, semver format, cli re-export) and `TestVersionCommand` (5 tests: subcommand, print output, -V, --version, help includes version)

---

## Milestone 50: Multi-instance — named bots via Docker

**Context**: `kiso-host.sh` and `install.sh` already exist and work. The Docker-native architecture is the current deployment model (single instance, container `kiso`, hardcoded port 8333, data in `~/.kiso/`). M50 extends the wrapper to support multiple named instances on the same machine without touching the Python core.

**Principle**: each instance is a bot with a unique name. The core knows nothing about "instances" — it's a Docker image that sees only `/root/.kiso`. All management is in the host wrapper.

---

### Local layout

```
~/.kiso/
  instances.json                   # registry (see below)
  instances/
    jarvis/                        # mounted as /root/.kiso in kiso-jarvis
      config.toml
      .env
      kiso.db
      sessions/
      roles/
      connectors/
        discord/
          config.toml              # webhook_port = 9001 (port from jarvis's range)
    work/
      config.toml                  # separate config (different models, providers, users)
      connectors/
        discord/
          config.toml              # webhook_port = 9101 (port from work's range)
```

**`~/.kiso/instances.json`**:
```json
{
  "jarvis": { "server_port": 8333, "connector_port_base": 9000 },
  "work":   { "server_port": 8334, "connector_port_base": 9100 }
}
```

---

### Ports — strategy

**Server port**: auto-detect first free starting from 8333.

**Connector port base**: auto-detect first free multiple of 100 starting from 9000 (10-port range per instance: base+1...base+10). Docker exposes the entire range: `-p {base+1}-{base+10}:{base+1}-{base+10}`. Internal port = external port (no asymmetric NAT — the connector knows its external port without extra configuration).

When `kiso connector install NAME` is run via wrapper:
1. The wrapper runs the install inside the container (as now)
2. Assigns the next free port from the instance's range
3. Overwrites `webhook_port` in the just-installed connector's `config.toml`
4. Registers the port in `instances.json`: `connectors: { discord: 9001 }`

---

### Implicit instance resolution

Applied to all commands when `--instance` is not specified:
- 0 instances → error: `"No bot configured. Run: kiso instance create NAME"`
- 1 instance → used implicitly (zero overhead for single-bot users)
- 2+ instances → error: `"Multiple bots available. Specify: kiso --instance NAME"`

---

### Commands — new wrapper

**Instance management** (all in the bash wrapper, not the Python CLI):

```bash
kiso instance create NAME          # create dir, docker run, register in instances.json
kiso instance start [NAME]         # docker start kiso-{NAME}
kiso instance stop [NAME]          # docker stop kiso-{NAME}
kiso instance restart [NAME]       # docker restart kiso-{NAME}
kiso instance list                 # name / server port / connector base / status
kiso instance status [NAME]        # container state + health check
kiso instance logs [NAME] [-f]     # docker logs kiso-{NAME}
kiso instance shell [NAME]         # docker exec -it kiso-{NAME} bash
kiso instance explore [NAME] [session]   # shell in the session workspace
kiso instance remove [NAME] [--yes]      # docker rm + rm -rf instances/{NAME}/
```

**Existing commands** — unchanged, accept optional `--instance`:
```bash
kiso [--instance NAME]                   # REPL
kiso [--instance NAME] msg "..."
kiso [--instance NAME] env set KEY VAL
kiso [--instance NAME] sessions
kiso [--instance NAME] skill install X
kiso [--instance NAME] connector run discord
kiso [--instance NAME] reset session
```

**Commands removed** (absorbed into `kiso instance *`):
`kiso up`, `kiso down`, `kiso restart`, `kiso status`, `kiso health`, `kiso logs`, `kiso shell`, `kiso explore`

---

### Instance name validation

Applied wherever the user provides a name (install.sh + `kiso instance create`):

- Format: `^[a-z0-9][a-z0-9-]*$` (or `^[a-z0-9]$` for 1-char names), max 32 characters
- Rationale: compatible with DNS hostname syntax, Docker container names, directory paths
- Clear error if invalid: `"Instance name must be lowercase alphanumeric + hyphens, no leading/trailing hyphen"`

---

### `install.sh` — updated flow

1. Check prerequisites (docker, git) — unchanged
2. **Ask for bot name** (default: `kiso`) — validated with regex above
3. Ask username, bot_name, provider, API key, models — unchanged
4. Create `~/.kiso/instances/NAME/config.toml` and `.env` (instead of `~/.kiso/config.toml`)
5. Auto-detect server port and connector base
6. Build Docker image — unchanged
7. `docker run -d --name kiso-{NAME} -p {server}:8333 -p {cbase+1}-{cbase+10}:{cbase+1}-{cbase+10} -v ~/.kiso/instances/{NAME}:/root/.kiso kiso:latest`
8. Register in `~/.kiso/instances.json`
9. Install wrapper and completions — unchanged

Re-running (`./install.sh` on an existing installation) offers: install another instance or update an existing one.

---

### Dockerfile — CMD → direct uvicorn

```dockerfile
# Before (removed):
CMD ["uv", "run", "kiso", "serve"]

# After:
CMD ["uv", "run", "uvicorn", "kiso.server:app", "--host", "0.0.0.0", "--port", "8333"]
```

Eliminates the dependency on `kiso serve` at runtime. Allows removing `kiso serve` from the Python parser without breaking anything.

---

### Python core changes

- `cli/__init__.py`: removal of `kiso serve` from parser and `main()` (the server no longer starts via CLI)
- Nothing else changes in the core

---

### Files to update

| File | Type of change |
|---|---|
| `kiso-host.sh` | complete rewrite |
| `install.sh` | flow refactor (bot name + multi-instance) |
| `Dockerfile` | CMD → uvicorn |
| `docker-compose.yml` | removed or reduced to dev tool |
| `completions/kiso.bash` + `kiso.zsh` | added `instance *` |
| `cli/__init__.py` | removal of `kiso serve` |
| `docs/docker.md` | complete rewrite |
| `docs/cli.md` | command reference update |
| `docs/config.md` | path `~/.kiso/instances/{name}/` |
| `docs/connectors.md` | path + connector port strategy |
| `docs/logging.md` | updated paths |

---

### Subtasks

- [x] 50a. Python core: removal of `kiso serve` from parser + Dockerfile CMD → uvicorn
- [x] 50b. `kiso-host.sh`: full rewrite — multi-instance, port resolution, `kiso instance *`, implicit resolution, connector port assignment on install
- [x] 50c. `install.sh`: bot name + `~/.kiso/instances/{name}/` + `instances.json` + docker run with port range
- [x] 50d. Docs: `docker.md` (rewrite), `cli.md`, `config.md`, `connectors.md`, `logging.md` + `completions/`

---

## Milestone 46: Plugin install — ask env vars before installing, with how-to instructions

**Problem observed in production**: the planner installed the discord connector, then discovered missing env vars from the install output, and only at the end asked the user for the values. Double problem:
1. The user waits for the entire install process before being prompted.
2. The message to the user didn't explain how to obtain the values (where to find the bot token, what the kiso token is, etc.).

**Root causes**:
1. The planner prompt said "install, then check" — wrong order.
2. The discord connector's `kiso.toml` had no `description` on env var fields.
3. `cli/connector.py` printed only `warning: VAR not set`, without description.

**Fix**:

- [x] `plugins/connector-discord/kiso.toml`: added `description` field to each env var (`bot_token`, `kiso_token`, `webhook_secret`) with instructions on how to obtain them
- [x] `cli/connector.py`: `_connector_install()` — prints `(required|optional) — {description}` next to each missing env var warning; uses `decl.items()` instead of `for key in env_decl` to access descriptions
- [x] `kiso/roles/planner.md`: "Plugin installation (MANDATORY)" rule rewritten as ordered list of 6 steps: (1) curl registry, (2) curl kiso.toml from GitHub BEFORE installing, (3) msg user with descriptions if env vars missing, (4) kiso env set, (5) install, (6) run
- [x] `tests/test_cli_connector.py`: `test_connector_install_env_warning_includes_description` — verifies that install output contains description next to warning for required and optional
- [x] `tests/test_brain.py`: `test_m46_plugin_install_checks_kiso_toml_before_install` — verifies that raw.githubusercontent.com/kiso.toml appears before `kiso connector install` in the prompt
- [x] `tests/test_brain.py`: `test_m46_plugin_install_includes_env_description_in_msg` — verifies that the prompt instructs the planner to include descriptions in the user message
- [x] `kiso/roles/messenger.md`: added "verbatim" rule — setup instructions (commands, URLs, step-by-step) must be reported exactly, not paraphrased
- [x] `tests/test_brain.py`: `test_verbatim_instructions_rule` — verifies that "verbatim" is in the messenger prompt

---

## Milestone 51: Infrastructure — automated tests for kiso-host.sh and install.sh

**Problem**: `kiso-host.sh` and `install.sh` have zero automated coverage. The logic for name validation, implicit instance resolution, port detection, and `kiso instance *` commands is entirely manually tested.

**Framework**: [bats-core](https://github.com/bats-core/bats-core) — the de facto standard for bash testing. Installed as a dev dependency (`tests/bash/bats/` via git submodule or downloaded in CI). No runtime dependencies.

**Mock strategy**: `PATH` is prepended with a `tests/bash/mocks/` directory containing stubs for `docker`, `git`, `ss`, `python3` (instances.json), etc. Tests verify flags, arguments, and observable side-effects (exit code, output, written files).

### 51a. Tests for `kiso-host.sh`

- [x] `tests/bash/test_host_name_validation.bats`: `validate_name()` — valid (`kiso`, `my-bot`, `a`), invalid (`MyBot`, `-bot`, `bot_name`, 33-char string, empty string)
- [x] `tests/bash/test_host_resolve_instance.bats`: 0 instances → exit 1 + message; 1 instance → implicit; 2+ instances without `--instance` → exit 1; 2+ instances with `--instance NAME` → NAME used
- [x] `tests/bash/test_host_instance_commands.bats`: `instance list`, `instance start`, `instance stop`, `instance restart`, `instance logs`, `instance shell` — verifies the correct container is targeted and docker flags are correct
- [x] `tests/bash/test_host_instance_remove.bats`: without `--yes` → prompts for confirmation; with `--yes` → removes without prompt; 'n' → abort
- [x] `tests/bash/test_host_instance_explore.bats`: non-existent SESSION in directory → exit 1 with message; existing SESSION → `docker exec` with `-e SESSION=...`
- [x] `tests/bash/test_host_port_detection.bats`: `_next_free_server_port()` skips ports already in use (mock `ss`); `_next_free_connector_base()` skips bases already in `instances.json`

### 51b. Tests for `install.sh`

- [x] `tests/bash/test_install_name_validation.bats`: same rules as 51a — valid, invalid, duplicate already in `instances.json`
- [x] `tests/bash/test_install_port_allocation.bats`: `next_free_server_port()` and `next_free_connector_base()` with mock `instances.json` containing existing instances
- [x] `tests/bash/test_install_register.bats`: `register_instance()` creates `instances.json` if missing; adds entry without overwriting existing instances

---

## Milestone 52: Core — multi-instance bug fixes

Three targeted fixes to `kiso-host.sh` identified during post-M50 analysis.

### 52a. `kiso instance explore` — SESSION validation

**Problem**: `kiso instance explore SESSION` enters the container even if `SESSION` does not exist as a workspace directory, producing a shell in `/` with no useful context.

**Fix**: before `docker exec`, verify that `~/.kiso/instances/{name}/sessions/{session}/` exists on the host. If missing → exit 1 with message "session '{session}' not found in instance '{name}'". If `SESSION` is omitted → shell in `/root/.kiso/` (current behavior, useful for debug).

- [x] `kiso-host.sh`: check `[ -d "$KISO_DIR/instances/$INST/sessions/$SESSION" ]` before `docker exec`; SESSION=default (hostname@user) when omitted
- [x] `tests/bash/test_host_instance_explore.bats`: updated — mkdir session in test "with SESSION"; new test "SESSION not found → error"

### 52b. `kiso instance remove` — interactive confirmation when `--yes` absent

**Problem**: without `--yes`, the command exits silently (or performs the remove without a prompt — to be verified). No test covers this today.

**Fix**: if `--yes` is absent → interactive prompt "Remove instance '{name}' and all its data? [y/N]"; default N; only `y`/`Y` proceeds.

- [x] `kiso-host.sh`: interactive prompt in the `remove` branch when `--yes` is not present (already implemented in M50)
- [x] `tests/bash/test_host_instance_remove.bats`: covered in M51 (5 tests: --yes, -y, 'y' stdin, 'n' abort, keeps others)

### 52c. `kiso instance create` — port already in use at docker run time

**Problem**: `_next_free_server_port()` checks ports at detection time; but between detection and `docker run` another instance may have claimed the port. Currently silent: docker run fails with an unhelpful error.

**Fix**: after `docker run`, verify the container is in `running` state (retry 1s × 3). If it doesn't start → `docker logs kiso-{NAME} | tail -20` + message "container failed to start — see above" + cleanup entry from `instances.json`.

- [x] `kiso-host.sh`: health check with retry (3×) after docker run; skip instances.json write on failure; `docker rm -f` cleanup
- [x] `tests/bash/test_host_instance_commands.bats`: test `create` fails → instances.json does not contain the entry; `sleep` mock in helpers for instant tests

---

## Milestone 53: Versioning — line count in `kiso version` command

**Goal**: `kiso version --stats` shows the project's line count, broken down by area, computed in Python (no `wc -l` — for portability and control over what to count).

**What is counted**: non-empty, non-comment lines (lines of code, LOC) in `.py` files of the project. Three areas:

| Area | Path | Description |
|---|---|---|
| `core` | `kiso/` | Main framework |
| `cli` | `cli/` | Interactive CLI |
| `tests` | `tests/` | Test suite |

**Output**:
```
kiso 0.1.0

  core     3 241 loc   (kiso/)
  cli      1 088 loc   (cli/)
  tests    8 470 loc   (tests/)
  ─────────────────
  total   12 799 loc
```

**Implementation**:

- [x] `kiso/_version.py`: new function `count_loc(root: Path) -> dict` + helper `_loc_in_dir(directory)` — rglob *.py, counts non-empty and non-comment lines
- [x] `cli/__init__.py`: `version_p.add_argument("--stats")`; `_print_version_stats()` calls `count_loc`, formats output with thousands separator (space); without `--stats` → current behavior
- [x] `tests/test_version.py`: `TestLocCounter` — 5 tests passed

---

## Milestone 54: `kiso stats` — token usage per session and instance

**Goal**: `kiso stats` command that aggregates token consumption data (already present in the audit log) by model, session, or role. The wrapper adds per-instance differentiation with `--all`.

### Current state

The data collection infrastructure is already complete:
- `kiso/audit.py`: every LLM call generates a JSONL row `{type, session, role, model, provider, input_tokens, output_tokens, duration_ms, status, timestamp}` in `~/.kiso/instances/{name}/audit/YYYY-MM-DD.jsonl`
- `kiso/llm.py`: tokens tracked in-memory via contextvars and written to the audit log
- `kiso/store.py`: tokens accumulated per task (`tasks.input_tokens/output_tokens`) and per plan (`plans.total_input_tokens/output_tokens`)

Only the aggregation and presentation layer is missing.

### 54a. Aggregation engine (`kiso/stats.py`)

- [x] `kiso/stats.py`: `read_audit_entries`, `aggregate`, `estimate_cost`, `MODEL_PRICES`
- [x] `tests/test_stats.py`: 16 unit tests (6 read_audit_entries, 6 aggregate, 4 estimate_cost)

### 54b. API endpoint `GET /admin/stats`

- [x] `kiso/main.py`: `GET /admin/stats` — admin-only, params `since`, `session`, `by`
- [x] `tests/test_stats.py`: 4 endpoint tests (admin guard, empty rows, aggregate by model, session filter)

### 54c. CLI `kiso stats`

- [x] `cli/stats.py`: `run_stats_command`, `print_stats`, `_fmt_k`, `_fmt_cost`
- [x] `cli/__init__.py`: subparser `stats` + dispatch + `/stats` REPL slash command + `_slash_stats`
- [x] `tests/test_cli.py`: 3 tests (subcommand exists, flags registered, defaults correct)
- [x] `docs/cli.md`: "Token Usage Statistics" section with examples and formatted output

### 54d. Wrapper `kiso stats [--all]` in `kiso-host.sh`

- [x] `kiso-host.sh`: `stats)` branch — resolves instance, delegates via `docker exec`; `--all` loops all instances with header
- [x] `tests/bash/test_host_stats.bats`: 4 tests (docker exec called, --since passed, --all headers, instance not running)

---

## Milestone 55: Autocomplete — shell, REPL, wrapper

**Goal**: consistent TAB completion across all three levels — bash/zsh shell (commands and dynamic arguments), interactive REPL (slash commands), Python CLI (registered subparsers).

### 55a. CLI `kiso completion bash|zsh` + wrapper handler

- [x] `kiso/completions/kiso.bash` and `kiso/completions/kiso.zsh`: scripts bundled in the Python package (via importlib.resources)
- [x] `cli/__init__.py`: subparser `completion shell` + dispatch that reads from `kiso/completions/`
- [x] `kiso-host.sh completion`: delegates to `docker exec kiso-$INST uv run kiso completion {shell}`; fallback to system install
- [x] `tests/test_cli.py`: 4 tests (bash contains `_kiso`/`complete -F`; zsh contains `#compdef kiso`; stats in both)
- [x] `tests/bash/test_host_completion.bats`: 3 tests (bash output, zsh output, invalid shell → error)

### 55b. Updated completions — `stats` + multi-instance sessions + `explore`

- [x] `kiso/completions/kiso.bash`: added `stats` to top-level commands; `stats)` branch with `--since/--session/--by/--all`; `_kiso_sessions()` uses `COMP_WORDS` to detect `--instance/-i`; `explore)` in instance sub-commands calls `_kiso_sessions`
- [x] `kiso/completions/kiso.zsh`: same changes; `_kiso_sessions()` uses `$words` (zsh completion global); `explore)` + `stats)` + `--session` top-level completed
- [x] `completions/kiso.bash` and `kiso.zsh`: synchronized

### 55c. REPL `/stats` slash command

- [x] `cli/__init__.py`: `/stats` in `_SLASH_COMMANDS`; `_slash_stats()` calls `GET /admin/stats?since=7&session=...&by=model`; already implemented in M54

---

## Milestone 56: Audit docs and tests — M54-M55 edge cases

**Goal**: fill documentation and test gaps discovered after M54-M55.

### 56a. Documentation

- [x] `docs/api.md`: complete `GET /admin/stats` section (params, response JSON, 400/403)
- [x] `docs/audit.md`: "Querying the Audit Log" section with `kiso stats` examples and dimensions table
- [x] `docs/cli.md`: error handling table for `kiso stats`; "Shell Completion" section with `source <(...)` examples
- [x] `docs/testing.md`: updated counts (unit ~1670, bats 60)

### 56b. Tests

- [x] `tests/test_stats.py`: `TestPrintStats` (6 tests: empty rows→"(no data)", all-unknown→cost column omitted, known model→column shown, single row, session filter in header, mixed known/unknown); `TestFmtHelpers` (7 tests: `_fmt_k` 0/999/1000/1.234M; `_fmt_cost` None/zero/small/normal)
- [x] `tests/test_stats.py`: `test_unreadable_file_silently_skipped`, `test_missing_field_falls_back_to_unknown`
- [x] `tests/bash/test_host_stats.bats`: `--all` with 0 instances shows message and exits 0; explicit `--instance` uses the specified instance

---

## Milestone 57: install.sh — UX naming (bot name first, derive instance id)

**Problem**: the old flow asked for instance name and display name as consecutive questions — counter-intuitive order and unclear distinction for the user.

**Solution**: ask for the bot's display name first, automatically derive the identifier via slug, show it for confirmation/override.

- [x] `install.sh`: `_derive_instance_name()` — slugify: lowercase, spaces/underscores→hyphens, strip non-alnum, collapse multiple hyphens, truncate to 32, fallback "kiso"
- [x] `install.sh`: `ask_bot_and_instance_name()` — replaces `ask_instance_name()` + `ask_bot_name()`; globals `BOT_NAME` and `INST_NAME`; flow: ask bot name [Kiso], show derived identifier, ask for confirmation/override
- [x] `docs/docker.md`: "Instance names" section updated with note on automatic derivation flow
- [x] `tests/bash/test_install_derive_name.bats`: 10 tests — passthrough, uppercase→lowercase, spaces→hyphens, underscores→hyphens, special chars stripped, consecutive hyphens collapsed, leading/trailing hyphens stripped, truncate to 32, empty input→"kiso", digits preserved

---

## Milestone 58: Dead code removal — migration and legacy session scope

**Goal**: remove backward-compatibility code for users/DBs that never existed (software not yet distributed).

### 58a. install.sh — remove single-instance layout check

- [x] `install.sh`: removed `OLD_CONFIG` block (18 lines) that detected the old `~/.kiso/config.toml` structure and suggested manual migration to multi-instance

### 58b. store.py — remove runtime migration and legacy session scope

- [x] `kiso/store.py`: removed `_migrate()` (54 lines) + FTS backfill — all columns already present in base SCHEMA; no old DB exists
- [x] `kiso/store.py`: removed `OR session IS NULL` from `get_facts` and `search_facts` — pre-M43 leftover for facts without a session; never existed in production
- [x] `kiso/worker/loop.py`: made explicit `is_admin=True` in the two places that called `get_facts(db)` without arguments (bump fact usage)
- [x] `tests/test_store.py`: removed `test_get_facts_null_session_user_fact_is_global`
- [x] `docs/flow.md`: removed point "user facts with session IS NULL (legacy): treated as global"

---

## Milestone 59: Security — path traversal, pub token, install source injection

**Goal**: fix three vulnerabilities identified during code review.

### 59a. Path traversal in `GET /pub/{token}/{path}` (`main.py:241`)

**Problem**: the check uses `str(file_path).startswith(str(pub_dir.resolve()))`. If `pub_dir=/home/user/pub`, the path `/home/user/pub-evil/secret` passes the check because it is a valid string prefix.

**Fix**: `file_path.resolve().is_relative_to(pub_dir.resolve())` (available since Python 3.9).

- [x] `kiso/main.py`: replace the startswith check with `Path.is_relative_to()`
- [x] `tests/test_published.py`: added `test_path_traversal_sibling_dir_blocked` — directory with identical prefix but different name is rejected

### 59b. Insecure pub token fallback (`pub.py:15`)

**Problem**: `config.tokens.get("cli") or "kiso"` — if the CLI token is not configured, pub token signing uses the guessable string `"kiso"`.

**Fix**: raise `ValueError` instead of using the fallback; `_report_pub_files()` catches and logs, returning `[]`.

- [x] `kiso/pub.py`: removed fallback `or "kiso"`; raised `ValueError` with explicit message
- [x] `kiso/worker/utils.py`: `_report_pub_files()` catches `ValueError` from `pub_token`, logs warning, returns `[]`
- [x] `tests/test_published.py`: `test_fallback_key_when_no_cli_token` → `test_raises_when_no_cli_token`

### 59c. Code injection in `install.sh` via `source "$ENV_FILE"` (`install.sh:657`)

**Problem**: `set -a; source "$ENV_FILE"; set +a` — if `.env` contains shell commands (not just `KEY=VALUE` assignments), they are executed with the installer's privileges.

**Fix**: `grep -E '^KISO_LLM_API_KEY='` + `cut` to extract only the needed value, without executing the file.

- [x] `install.sh`: replaced `source "$ENV_FILE"` with safe read via grep/cut; temporary variable `_api_key_check` unset after the check
- [x] `tests/bash/test_install_env_safe_read.bats`: 5 tests — normal read, command injection blocked, subshell blocked, missing key, commented line ignored
- [x] `docs/security.md`: "Published File Security" section rewritten (was incorrect: said UUID4, it's HMAC-SHA256); added detail on `is_relative_to`, symlinks, missing token
- [x] `docs/api.md`: path traversal description updated with `is_relative_to` and covered vectors; note on missing CLI token
- [x] `tests/test_published.py`: added `test_path_traversal_symlink_blocked` and `test_path_traversal_absolute_filename_blocked`
- [x] `tests/test_worker.py`: added `test_empty_when_no_cli_token` for `_report_pub_files`

---

## Milestone 60: Correctness — store atomicity, transactions, zombie processes

**Goal**: fix race conditions, transactional inconsistency, and resource leaks identified during code review.

### 60a. `append_task_llm_call` not atomic (`store.py:340`)

**Problem**: reads JSON → deserializes → appends → rewrites. If two coroutines write to the same task row in parallel, one overwrites the other.

**Fix**: native atomic SQLite operation with `json_insert`:
```sql
UPDATE tasks SET llm_calls = json_insert(COALESCE(llm_calls, '[]'), '$[#]', json(?)) WHERE id = ?
```

- [x] `kiso/store.py`: rewrite `append_task_llm_call()` with native SQLite `json_insert` — uses `CASE WHEN json_valid(llm_calls) THEN llm_calls ELSE '[]' END` to handle NULL and corrupt JSON
- [x] `tests/test_store.py`: `test_append_task_llm_call_atomic_no_data_loss` — 10 concurrent appends via `asyncio.gather`, verifies all present without duplicates/losses

### 60b. `recover_stale_running` without transaction (`store.py:510`)

**Problem**: two separate UPDATEs (plans and tasks) without a transaction — if the process dies between the two, plans are reset but tasks remain `running`.

**Analysis**: the two UPDATEs are already in a single implicit aiosqlite transaction (a single `db.commit()` at the end of the function). No real bug.

- [x] `kiso/store.py`: verified — no changes needed, the two UPDATEs already share the same implicit transaction

### 60c. Zombie processes on `asyncio.TimeoutError` (`exec.py:35`, `skill.py:35`)

**Problem**: when `asyncio.wait_for` times out, the child process keeps running. No `proc.kill()` or `await proc.wait()` in the timeout path.

**Fix**:
```python
except asyncio.TimeoutError:
    proc.kill()
    await proc.wait()
    return "", "Timed out", False
```

- [x] `kiso/worker/exec.py`: added kill + wait in the `TimeoutError` handler
- [x] `kiso/worker/skill.py`: same fix
- [x] `tests/test_worker.py`: `test_timeout_kills_process` in `TestExecTask` and `TestSkillTask` — mock subprocess, verifies `kill` and `wait` called on timeout

### 60d. Non-atomic connector status write (`connector.py:120`)

**Problem**: `_write_status()` writes directly to the JSON file — if a reader accesses it mid-write, it gets truncated/corrupt JSON.

**Fix**: write to `.tmp` then `os.replace()` (atomic on POSIX).

- [x] `cli/connector.py`: rewrite `_write_status()` with write-tmp + replace pattern — uses `status_file.with_suffix(".tmp")` and `tmp_file.replace(status_file)`
- [x] `tests/test_cli_connector.py`: existing tests verify the behavior; atomic write does not alter the public interface

---

## Milestone 61: Performance — connection pooling, cache, transaction batching

**Goal**: eliminate redundant I/O and allocations identified during code review.

### 61a. HTTP connection pooling for LLM calls (`llm.py`)

**Problem**: new `httpx.AsyncClient` on every LLM call — each time a new TLS handshake. With a 10-task plan × 3 retries = 30+ TCP connections.

**Fix**: shared module-level client, initialized from `main.py` lifespan. Fallback to per-call client when `_http_client is None` (tests, standalone use).

- [x] `kiso/llm.py`: `_http_client: httpx.AsyncClient | None`, `init_http_client(timeout)`, `close_http_client()`. `call_llm` uses the shared client if available, otherwise `async with httpx.AsyncClient(...)`.
- [x] `kiso/main.py`: `init_http_client(timeout=exec_timeout)` at startup, `close_http_client()` at shutdown.
- [x] `tests/test_llm.py`: 3 new tests (`TestSharedHttpClient`) — shared client used, per-call fallback, init+close.

### 61b. Cache `discover_skills()` (`skills.py`) — REVERTED

**Note**: the cache was implemented and then removed (commit "M61b: remove discover_skills cache — scan on every call"). The scan is fast enough (parsing TOML of a few files) to not justify the added complexity. `discover_skills()` rescans on every call — no cache.

- [x] Implemented and then removed: no caching code in the current source
- [x] `tests/test_skills.py`: `TestDiscoverSkillsNoCache` — verifies that newly installed skills are immediately visible without invalidating anything

### 61c. Audit dir init only once (`audit.py`)

**Problem**: `mkdir(parents=True, exist_ok=True)` + `os.chmod(0o700)` executed on every write to the audit log.

**Fix**: `_audit_dir_ready: set[Path]` — the directory is initialized only on first access per process.

- [x] `kiso/audit.py`: `_ensure_audit_dir(path)` with guard `_audit_dir_ready`
- [x] `tests/test_audit.py`: `TestEnsureAuditDir` — 3 tests (creates dir + permissions, mkdir called only once, N `_write_entry` → chmod only once)

### 61d. `rglob` with `islice` for large workspaces (`sysenv.py`)

**Analysis**: `_collect_workspace_files()` already uses a loop with `break` at `_MAX_SCAN=1000` candidates — never materializes the entire tree. Refactoring with `islice` would be purely cosmetic on already correct and lazy logic.

- [x] `kiso/sysenv.py`: verified — no changes needed

### 61e. `httpx.AsyncClient` singleton in `webhook.py`

**Problem**: the client is created inside the retry loop — 3 attempts = 3 TCP connections.

**Fix**: `async with httpx.AsyncClient(...)` wraps the entire retry loop.

- [x] `kiso/webhook.py`: `async with httpx.AsyncClient(timeout=10.0, follow_redirects=False) as client:` moved outside the `for attempt, delay in ...`

### 61f. `rich.Console` singleton in `render.py`

**Analysis**: the `Console` in `render.py` is parameterized per-call with `file=buf` (StringIO/AsciiBuffer), `width=caps.width`, `force_terminal`, `no_color` — all dependent on the current `TermCaps`. Cannot be a singleton. No changes.

- [x] `cli/render.py`: verified — no changes needed

---

## Milestone 62: Worker refactor — dispatch, split `_process_message`, dedup task-step ✅

**Goal**: reduce cyclomatic complexity and duplication in the core of the worker.

### 62a. Dispatch pattern in `_execute_plan()` ✅

- [x] `kiso/worker/loop.py`: extracted `_handle_exec_task`, `_handle_msg_task`, `_handle_skill_task`, `_handle_search_task`, `_handle_replan_task` + `_PlanCtx` + `_TaskHandlerResult`
- [x] `kiso/worker/loop.py`: if/elif replaced with `_TASK_HANDLERS.get(task_type)`. `_execute_plan` reduced from ~533 to ~80 lines
- [x] `tests/test_worker.py`: `TestTaskHandlers` (9 tests per handler in isolation)

### 62b. Deduplicate the task-step pattern ✅

- [x] `kiso/worker/loop.py`: extracted `_store_step_usage()` and `_run_review_step()` — used by exec, skill, search handlers to eliminate duplication
- Note: general `_run_task_step` not extracted (review/usage pattern not uniform enough across task types); the two specific helpers cover ~80% of the effective duplication

### 62c. Split `_process_message()` ✅

- [x] `kiso/worker/loop.py`: extracted `_run_planning_loop()` — while-True replan loop (~280 lines). `_process_message` reduced from ~435 to ~105 lines
- [x] `kiso/worker/__init__.py`: all new names exported for testability
- [x] `tests/test_worker.py`: `TestRunPlanningLoop` (2 tests: success path, failure path)

---

## Milestone 63: Plugin system refactor — dedup install, validate, subprocess ✅

**Goal**: eliminate ~300+ lines of duplication between skill and connector.

### 63a. Unify `_skill_install` and `_connector_install` (`skill.py`, `connector.py`)

**Problem**: the two functions are ~150 lines of nearly identical code — clone → marker → validate → unofficial warning → `uv sync` → `deps.sh` → `check_deps` → `check_env_vars` → remove marker.

**Fix**: extract `_plugin_install(plugin_dir, plugin_type, validate_fn, check_deps_fn)` in `plugin_ops.py`.

- [x] `cli/plugin_ops.py`: add `_plugin_install()` parameterized (with `post_install` callback)
- [x] `cli/skill.py`: delegate to `_plugin_install`; `_skill_post_install()` for env vars, usage_guide, git exclude
- [x] `cli/connector.py`: delegate to `_plugin_install`; `_connector_post_install()` for env vars + config.example.toml
- [x] Tests: behavior verified (patch target `check_deps_fn` passed as parameter)

### 63b. Unify `_validate_*_manifest` (`skills.py`, `connectors.py`)

**Problem**: `_validate_connector_manifest()` and `_validate_skill_manifest()` duplicate the same logic (required fields, version format, env vars, commands). They differ only in field names.

**Fix**: `_validate_manifest(manifest, required_fields, manifest_type)` in a shared module.

- [x] Extracted in `kiso/plugins.py`: `_validate_plugin_manifest_base(manifest, plugin_dir, plugin_type)`
- [x] `kiso/skills.py`: `_validate_manifest` calls base + skill-specific checks
- [x] `kiso/connectors.py`: `_validate_connector_manifest` delegates directly to base
- [x] `tests/test_skills.py`: `TestValidatePluginManifestBase` (7 tests)

### 63c. Extract `_run_subprocess` from `exec.py` and `skill.py`

**Problem**: `run_exec()` and `run_skill()` have identical structure — command construction, `asyncio.create_subprocess_exec`, `wait_for`, `communicate`, output/error handling.

**Fix**: `async def _run_subprocess(cmd, env, timeout, cwd) -> SubprocessResult` in `worker/utils.py`.

- [x] `kiso/worker/utils.py`: add `_run_subprocess()` (shell/exec, stdin, uid, max_output_size)
- [x] `kiso/worker/exec.py`: delegate to `_run_subprocess`
- [x] `kiso/worker/skill.py`: delegate to `_run_subprocess`
- [x] `kiso/worker/__init__.py`: exported `_run_subprocess`
- [x] `tests/test_worker.py`: `TestRunSubprocess` (5 tests); patch targets updated to `kiso.worker.utils.asyncio.*`

---

## Milestone 64: CLI and brain refactor — split `_poll_status`, simplify `_retry_llm` ✅

**Goal**: reduce the longest functions in the CLI and brain.

### 64a. Split `_poll_status()` (`cli/__init__.py:200`)

**Problem**: ~380 lines mixing polling, rendering, spinner management, and stop conditions.

**Fix**: extract:
- `_render_plan_status(data, verbose) -> None` — rendering only
- `_should_stop_polling(data) -> bool` — stop conditions
- `_poll_status(session, ...)` — loop only, calls the others

- [x] `cli/__init__.py`: `_PollRenderState` (dataclass), `_should_stop_polling(plan, tasks, message_id, worker_running, seen, failed_stable_polls) -> tuple[bool, int]`, `_render_plan_status(data, message_id, quiet, verbose, caps, bot_name, state) -> list` — mutates state in-place
- [x] `tests/test_cli.py`: `TestShouldStopPolling` (9 tests), `TestRenderPlanStatus` (7 tests)

### 64b. Simplify `_retry_llm_with_validation()` (`brain.py:65`)

**Problem**: handles 3 distinct cases (planner, reviewer, curator) with all-optional parameters. High cyclomatic complexity.

**Fix**: separate into `_retry_with_json_schema()` and `_retry_with_key_check()`, or use an injectable `validator` callable.

- [x] `kiso/brain.py`: removed `validate_kwargs`; `validate_fn` always has signature `(result) -> list[str]`; callers use lambda where needed (`run_planner`, `run_curator`)

### 64c. Deduplicate setup in `_chat()` and `_msg_cmd()` (`cli/__init__.py:750`)

**Problem**: ~60 lines of identical setup (config loading, token, user/session, httpx client) in two functions.

**Fix**: extract `_setup_client_context(args) -> ClientContext` (namedtuple or dataclass).

- [x] `cli/__init__.py`: `_ClientContext(NamedTuple)` + `_setup_client_context(args)` — used by `_chat` and `_msg_cmd`

---

## Milestone 65: Tech debt — TypedDict, cache prompts, bash robustness, log rotation ✅

**Goal**: resolve low-priority tech debt accumulated during development.

### 65a. TypedDict for store entities (`store.py`)

**Problem**: `dict[str, Any]` used everywhere for session, message, task, fact — no semantic distinction, no type checker support.

**Fix**: define `TypedDict` for the 4 main entities: `Session`, `Message`, `Task`, `Fact`.

- [x] `kiso/store.py`: add `SessionDict`, `MessageDict`, `PlanDict`, `TaskDict`, `FactDict`; update signatures of main store functions

### 65b. Cache `_load_system_prompt()` (`brain.py:120`)

**Problem**: role files are re-read from disk on every LLM call. The `invalidate_cache()` cache already exists for `sysenv` — extend the same pattern.

- [x] `kiso/brain.py`: add `_prompt_cache: dict[str, str] = {}` and `invalidate_prompt_cache()`; autouse fixture in `test_brain.py` for isolation

### 65c. `MODEL_PRICES` — ordering enforcement (`stats.py:20`)

**Problem**: matching depends on key order in the dict — "more specific before less specific" is documented but not verified. Adding a key in the wrong position silently breaks cost estimates.

- [x] `tests/test_stats.py`: `TestFindPriceOrdering` — 8 tests on gemini-2.x vs gemini-flash, gpt-4o-mini vs gpt-4o, llama-3.3 vs llama-3, dict key order

### 65d. `build_secret_variants()` silent on exception (`security.py:120`)

**Problem**: if building variants for a secret fails (e.g. encoding error), the exception is silently swallowed.

- [x] `kiso/security.py`: added `import logging` + `log`; `logger.error(...)` in the except block

### 65e. Bash robustness: `set -euo pipefail` in `kiso-host.sh`, `base_url` unbound in `install.sh`

**Problem 1**: `kiso-host.sh` does not use `set -euo pipefail` — intermediate errors are ignored.
**Problem 2**: `install.sh:639` — `base_url="${base_url:-...}"` can be unbound with `set -u` if `NEED_CONFIG=false`.
**Problem 3**: `install.sh:300` — non-interactive detection uses `ARG_USER && ARG_API_KEY` instead of `[[ ! -t 0 ]]`.
**Problem 4**: `install.sh:450` — `while *--*` loop in `_derive_instance_name` is O(n²) on degenerate input. Fix: `raw=$(printf '%s' "$raw" | tr -s '-')`.

- [x] `kiso-host.sh`: already had `set -euo pipefail` ✓
- [x] `install.sh`: `base_url=""` initialized before the NEED_CONFIG block; `tr -s '-'` in `_derive_instance_name`; `[[ ! -t 0 ]]` added to non-interactive detection in `ask_models`
- [x] `tests/bash/test_install.bats`: 10 bats tests for `_derive_instance_name`

### 65f. Log rotation for session log (`log.py`)

**Problem**: session logs are never rotated.

- [x] `kiso/log.py`: `RotatingFileHandler` for session log (2 MB, 2 backups); test `test_session_log_uses_rotating_handler`

### 65g. `SessionLogger` — add `debug()` and `exception()` methods (`log.py:40`)

- [x] `kiso/log.py`: added `debug()` and `exception()` to `SessionLogger`; tests in `test_log.py`

### 65h. Fragile `client` fixture in `conftest.py` relative to `lifespan` (`conftest.py:143`)

**Problem**: `app.state.config` and `app.state.db` set directly in the fixture. If `lifespan()` initializes new fields, tests break silently.

**Fix**: extract `_init_app_state(app, config, db)` from `lifespan()`, used both in production and in tests.

- [x] `kiso/main.py`: extracted `_init_app_state()`
- [x] `tests/conftest.py`: updated `client` fixture to use it

---

## Milestone 66: Code review — performance, correctness, robustness

Improvements identified during a systematic code review of the codebase. No user-visible behavior changes.

---

### 66a. Performance — `_post_plan_knowledge` parallelism

**Problem**: Curator (LLM call) and Summarizer (LLM call) run serially even though they are completely independent. With both active, post-plan time includes two sequential LLM calls. Decay and Archive (SQL only) same issue.

**Fix**: three phases instead of five sequential:
1. `asyncio.gather(curator, summarizer)` — independent, no data dependency
2. Fact consolidation — after curator (sees newly promoted facts)
3. `asyncio.gather(decay, archive)` — SQL only, independent

- [x] `kiso/worker/loop.py`: `_post_plan_knowledge()` — phase 1: `asyncio.gather` on curator and summarizer; phase 3: `asyncio.gather` on decay and archive
- [x] `tests/test_worker.py`: `TestPostPlanKnowledgeParallel` — verifies curator and summarizer called with `gather`; consolidation launched after; decay and archive with `gather`

---

### 66b. Correctness — `update_task_review` does not update `updated_at`

**Problem**: `update_task` and `update_task_substatus` update `updated_at = CURRENT_TIMESTAMP`; `update_task_review` does not. A task receiving the reviewer's verdict does not update its timestamp — the `/status` polling may serve stale data.

**Fix**: add `updated_at = CURRENT_TIMESTAMP` to the UPDATE.

- [x] `kiso/store.py`: `update_task_review()` — added `updated_at = CURRENT_TIMESTAMP` to the UPDATE query
- [x] `tests/test_store.py`: `test_update_task_review_bumps_updated_at` — verifies `updated_at` changes after the call

---

### 66c. Robustness — missing `PRAGMA busy_timeout`

**Problem**: `init_db` sets WAL but not `busy_timeout`. If two coroutines commit close together (substatus update + task update in the same cycle), SQLite may return `SQLITE_BUSY` immediately instead of waiting briefly.

**Fix**: add `PRAGMA busy_timeout = 5000` (5 seconds) immediately after `PRAGMA journal_mode=WAL`.

- [x] `kiso/store.py`: `init_db()` — `await db.execute("PRAGMA busy_timeout = 5000")`
- [x] `tests/test_store.py`: `test_busy_timeout_is_set` — verifies the pragma is active on the test db

---

### 66d. API — unused `collect_deploy_secrets` parameter

**Problem**: `collect_deploy_secrets(config=None)` declares `config` but never reads it. Every caller invokes it without arguments. The parameter misleadingly suggests that `config` affects secret collection.

**Fix**: remove the parameter.

- [x] `kiso/security.py`: `collect_deploy_secrets()` — removed `config=None`
- [x] `kiso/worker/loop.py`: call sites unchanged (already called without argument)
- [x] `tests/test_security.py`: verify existing tests pass

---

### 66e. Maintainability — `build_*_messages` declared `async` without `await`

**Problem**: `build_reviewer_messages`, `build_paraphraser_messages`, `build_summarizer_messages`, `build_searcher_messages`, `build_exec_translator_messages`, `build_messenger_messages`, `build_classifier_messages` are `async def` but contain no `await`. Callers await a coroutine that does no I/O, with unnecessary scheduling overhead and a misleading API about the function's contract.

**Fix**: convert to regular `def`; update call sites that `await` them.

- [x] `kiso/brain.py`: 7 `build_*_messages` functions from `async def` to `def`; removed `await` at internal call sites in `brain.py`
- [x] `tests/test_brain.py`: verify existing tests pass (no functional changes)

---

### 66f. Robustness — silent FTS5 fallback

**Problem**: the `except Exception` block in `search_facts` that activates the fallback to `get_facts` does not log the exception. If FTS5 fails for an unexpected reason (corrupt table, bug), the degradation happens invisibly.

**Fix**: add `log.debug(...)` in the except block with the exception and `exc_info=True`.

- [x] `kiso/store.py`: `search_facts()` — `except Exception as exc: log.debug("FTS search failed, falling back: %s", exc, exc_info=True)`
- [x] `tests/test_store.py`: `test_fts5_fallback_logs_debug` — mock db that raises exception on FTS query; verifies `log.debug` is called

---

### 66g. Style — `import json` inside function + missing `encoding`

**Problem 1**: `_strip_llm_verbose` in `main.py` imports `json` inside the function body (`import json as _json`). Every call to `/status` executes an import statement.

**Problem 2**: `_load_env_file` uses `path.read_text()` without `encoding="utf-8"`. The rest of the codebase specifies encoding explicitly (e.g. `_init_kiso_dirs:69`).

**Fix**: `import json` at module level; `encoding="utf-8"` in `read_text`.

- [x] `kiso/main.py`: `import json` moved to module level; `path.read_text(encoding="utf-8")` in `_load_env_file`

---

### 66h. Performance — `check_deps` re-reads `kiso.toml`

**Problem**: `discover_skills()` parses `kiso.toml` for each skill and builds the dict. `check_deps()` receives that dict but reopens and re-parses the same `kiso.toml` to read `[kiso.deps]` — double I/O for the same information.

**Fix**: include `"deps"` in the dict returned by `discover_skills`; `check_deps` uses `skill.get("deps", {})` without I/O.

- [x] `kiso/skills.py`: `discover_skills()` — added `"deps": manifest.get("kiso", {}).get("deps", {})` to the skill dict
- [x] `kiso/skills.py`: `check_deps()` — uses `skill.get("deps", {}).get("bin", [])` without opening files; keeps fallback to file read if `"deps"` absent (compat with old dicts)
- [x] `tests/test_skills.py`: `test_check_deps_uses_skill_dict_no_io` — verifies `open` is not called when the dict already contains `"deps"`

---

### 66i. Type and style — `_PlanCtx` generics + long import

**Problem 1**: `_PlanCtx.deploy_secrets: dict`, `session_secrets: dict`, `installed_skills: list` use unparameterized types. Inconsistent with the rest of the codebase.

**Problem 2**: `from kiso.llm import ...` in `loop.py` is a 142-character line.

**Fix**: add type parameters; wrap the import over multiple lines.

- [x] `kiso/worker/loop.py`: `_PlanCtx` — `deploy_secrets: dict[str, str]`, `session_secrets: dict[str, str]`, `installed_skills: list[dict]`
- [x] `kiso/worker/loop.py`: `kiso.llm` import wrapped with parentheses over multiple lines

---

## Milestone 67: install.sh — simplified re-install menu

**Problem**: the menu that appeared when instances were already installed was conceptually wrong:
1. Three heterogeneous options: "Add a new instance", "Update Docker image", "Remove an existing instance" — mixing operations of different scope (global vs per-instance) and including a destructive operation ("remove") that has no place in an installer.
2. "Update Docker image" exposed the implementation detail (Docker) to the user, who doesn't know what a Docker image is.
3. "Remove instance" doesn't belong in an installer — it's a maintenance operation for the CLI wrapper.

**Correct principle**: an installer installs. Re-running it makes sense only for two things: installing another instance, or reinstalling an existing one. Reinstallation follows the same normal flow, with the additional option of a factory reset first.

**Fix**: menu reduced to two options; no reference to Docker; factory reset as the first question in the update flow.

- [x] `install.sh`: menu reduced to "Install another instance" / "Update instance 'X'" (or "Update an existing instance" if multiple)
- [x] `install.sh`: removed "Update Docker image (rebuild + restart all)" option
- [x] `install.sh`: removed "Remove an existing instance" option
- [x] `install.sh`: `update-instance` mode — first question: "Reset data? (wipes store.db, messages, learnings, facts — keeps config.toml and .env)"; then continues the normal flow (keep/overwrite config, keep/overwrite .env, rebuild container)
- [x] `install.sh`: in `update-instance` mode ports are read from `instances.json` instead of being re-detected (no port change on reinstall)
- [x] `docs/docker.md`: "Installation" section — re-install options updated

---

## ~~Milestone 68~~: `version` — show total line count inline ✓

**Problem**: `kiso version` printed only `kiso 0.2.0`. The line count was hidden behind `--stats`, a flag most users would never discover.

**Fix**: plain `kiso version` (and `-V`) appends the total on the same line: `kiso 0.2.0  (7742 lines)`. `-V --stats` shows the full per-area breakdown. `loc` renamed to `lines` for clarity; thousands separator removed.

- [x] `cli/__init__.py`: `_VersionAction` replaces `action="version"` — computes LOC at call time, supports `--stats` via `sys.argv` inspection
- [x] `cli/__init__.py`: `_fmt_loc` extracted to module level; plain int, no thousands separator; label `loc` → `lines`
- [x] `tests/test_cli.py`: `test_version_plain_shows_loc`, `test_version_stats_unchanged`, `test_version_flag_stats_shows_breakdown`, `test_version_flag_long_prints_version` updated

---

## ~~Milestone 69~~: session workspace — cartella `uploads/` per sessione ✓

**Problem**: ogni sessione aveva solo `pub/` (file serviti esternamente). Nessun posto dedicato per file che arrivano dall'esterno — allegati email, file Discord/Telegram, upload manuali — che i connettori e le feature future devono poter scrivere in un path stabile senza crearlo ogni volta.

**Fix**: `_session_workspace()` crea `uploads/` accanto a `pub/` ad ogni inizializzazione del workspace. Nessuna logica di upload per ora — solo la directory garantita.

- [x] `kiso/worker/utils.py`: `_session_workspace()` — `uploads_dir = workspace / "uploads"; uploads_dir.mkdir(exist_ok=True)`; chown incluso se `sandbox_uid` presente
- [x] `tests/test_worker.py`: `test_workspace_creates_uploads_dir`; `test_workspace_chown_chmod` aggiornato (chown count 2 → 3)
- [x] `docs/flow.md`: sezione "Uploads Directory" che spiega scopo e contratto della cartella
- [x] `docs/docker.md`: struttura directory aggiornata con `uploads/` sotto `sessions/{session}/`

---

## ~~Milestone 70~~: Autocomplete — shell completion fixes ✓

**Problem**: tre bug critici trovati durante i test manuali pre-release:

1. `_kiso_sessions` interrogava `kiso.db` ma il database si chiama `store.db` — la completion di sessioni non funzionava mai.
2. `kiso skill update/remove` e `kiso connector update/remove/run/stop/status` non completavano i nomi installati.
3. `kiso skill install` e `kiso connector install` mancavano di `--show-deps`.

**Fix**: riscrittura dei file di completion bash e zsh.

- [x] `kiso/completions/kiso.bash`, `completions/kiso.bash`: `_kiso_sessions` — `kiso.db` → `store.db`
- [x] `kiso/completions/kiso.bash`, `completions/kiso.bash`: estratto `_kiso_active_instance()` — elimina la duplicazione della logica di risoluzione istanza
- [x] `kiso/completions/kiso.bash`, `completions/kiso.bash`: aggiunti `_kiso_skill_names()` e `_kiso_connector_names()` via `docker exec ls`
- [x] `kiso/completions/kiso.bash`, `completions/kiso.bash`: `skill install` — aggiunto `--show-deps`; `skill update` — completa con `all` + nomi; `skill remove` — completa con nomi
- [x] `kiso/completions/kiso.bash`, `completions/kiso.bash`: `connector install` — aggiunto `--show-deps`; `connector update` — `all` + nomi; `connector remove/run/stop/status` — nomi
- [x] `kiso/completions/kiso.zsh`, `completions/kiso.zsh`: stesse fix equivalenti per zsh

---

## ~~Milestone 71~~: wrapper — porta interna vs porta esterna ✓

**Problem**: `kiso-host.sh` passava `--api "http://localhost:$SERVER_PORT"` ai comandi eseguiti via `docker exec`. `$SERVER_PORT` è la porta **esterna** dell'host (da `instances.json`, e.g. 8334). Ma il CLI gira dentro il container, dove il server ascolta sulla porta **interna** (da `config.toml`, sempre 8333 di default). Con la prima istanza funzionava per coincidenza (8333 == 8333). Dalla seconda in poi il CLI non riusciva a connettersi.

**Fix**: aggiunta `instance_internal_port()` che legge `[settings] port` da `config.toml` via regex. Tutti i `docker exec` usano ora la porta interna. `SERVER_PORT` rimane usato solo per operazioni lato host (health check, port mapping in `docker run`).

- [x] `kiso-host.sh`: `instance_internal_port()` — legge `port` da `~/.kiso/instances/{name}/config.toml`, fallback a 8333
- [x] `kiso-host.sh`: proxy (chat, msg, e tutti gli altri comandi) — `$SERVER_PORT` → `$INTERNAL_PORT`
- [x] `kiso-host.sh`: `stats` (singola istanza e `--all`) — `$SERVER_PORT` / `$_port` → `$INTERNAL_PORT` / `$_iport`
- [x] `kiso-host.sh`: `reset` — `$SERVER_PORT` → `$INTERNAL_PORT`
- [x] `kiso-host.sh`: help text — `kiso.db` → `store.db`

---

## Milestone 72: Planner + Reviewer — qualità comportamentale

Quattro problemi osservati durante i test manuali pre-release. Tre riguardano il prompt del planner, uno lo schema del reviewer.

### 72a. Planner: kiso management commands nel prompt

**Problem**: il planner non sa che `kiso skill install/update/remove`, `kiso connector install/update/remove/run/stop/status` e `kiso env set/delete/reload` sono exec primitivi disponibili. Quando l'utente chiede di installare qualcosa di disponibile come skill, il planner usa pip/apt invece del Kiso layer.

**Observed**: "installa aider" → piano con `pip install aider-chat` invece di `kiso skill install aider`.

**Fix**: sezione nel prompt del planner con tutti i kiso management commands e la loro sintassi esatta. Il planner può referenziarli in task `exec`.

- [x] `kiso/roles/planner.md`: aggiungere sezione "Kiso management commands" con `kiso skill install/update/remove <name>`, `kiso connector install/update/remove/run/stop/status <name>`, `kiso env set/get/delete/reload`

### 72b. Planner: risoluzione ambigua per installazioni

**Problem**: "installa aider" è ambiguo — potrebbe essere la skill kiso o il tool di sistema. Il planner deve chiedere se non è esplicito. Problema aggravato dal fatto che il planner generava il piano con `pip install` nello stesso piano del registry check, PRIMA di avere i risultati.

**Fix**: se il contesto è esplicito ("la skill X"), procedere direttamente con `kiso skill install`. Se ambiguo, fare il registry check via exec + `replan` (non includere l'install nello stesso piano del check). Pacchetti di sistema noti (git, curl, docker, ecc.) → sistema package manager direttamente.

- [x] `kiso/roles/planner.md`: regola aggiornata per richieste di installazione ambigue con replan obbligatorio dopo registry check

### 72c. Planner: lingua della risposta nel detail dei msg task

**Problem**: il messenger risponde nella lingua del task `detail` (scritto dal planner in inglese), non nella lingua dell'utente. Il messenger non vede la conversazione per design — non può rilevare la lingua da solo.

**Fix** (minima, zero schema change): il planner aggiunge `[Lang: it]` (o la lingua rilevata) come prima riga del `detail` dei task `msg`. Il messenger la legge e risponde in quella lingua. Overhead: ~5 token per msg task.

Alternative scartate: passare la conversazione al messenger (rompe il design); campo `language` nello schema (sproporzionato al beneficio).

- [x] `kiso/roles/planner.md`: regola — per ogni task `msg`, aggiungere `[Lang: xx]` (ISO 639-1) come prefisso del detail
- [x] `kiso/roles/messenger.md`: se il detail inizia con `[Lang: xx]`, rispondere in quella lingua

### 72d. Reviewer: `learn` → array di learning atomici

**Problem**: il reviewer emette un unico string di learning anche quando il task produce più fatti distinti di categorie diverse. Il curator riceve un blob invece di item separati, degradando la qualità della knowledge base.

**Observed**: `"The user speaks Italian. The system has a registry containing at least four skills (search, aider, browser, moltbook) and one connector (discord)."` — tre fatti distinti (`user`, `general`, `general`) come stringa unica.

**Fix**: `learn` passa da `string | null` a `string[] | null` (max 5 items). Ogni elemento = un fatto atomico. Il codice itera l'array e crea un entry in `store.learnings` per ogni item. Il curator non cambia — già valuta ogni learning come entry indipendente.

- [ ] `kiso/brain.py`: schema reviewer — `"learn": {"type": ["array", "null"], "items": {"type": "string"}, "maxItems": 5}`
- [ ] `kiso/worker/loop.py`: righe 452–455 — `for item in (review.get("learn") or []): await save_learning(db, item, session)`
- [ ] `kiso/roles/reviewer.md`: istruzione a emettere item atomici separati, un fatto discreto per item, max 5
- [ ] `tests/test_brain.py`: aggiornare test dello schema reviewer per array
