# Testing

## Quick Reference

```bash
# Unit tests (fast, no network, no secrets)
uv run pytest tests/ -q

# Live tests in Docker (safe — LLM-generated commands isolated in container)
docker compose -f docker-compose.test.yml run --rm test-live

# Everything
uv run pytest tests/ -q && docker compose -f docker-compose.test.yml run --rm test-live
```

## Stack

| Tool | Why |
|------|-----|
| pytest | Standard Python test runner, rich plugin ecosystem |
| pytest-asyncio | Async test support for FastAPI lifespan and async fixtures |
| httpx | Async HTTP client with ASGI transport — test endpoints without a running server |
| pytest-cov | Coverage reporting with fail-under gate |

## Directory Structure

```
tests/
├── conftest.py              # shared fixtures (test config, async client, --llm-live/--live-network flags)
├── fixtures/                # static test data (sample configs, etc.)
├── test_config.py           # config loading and validation
├── test_health.py           # GET /health endpoint
├── test_sandbox_docker.py   # sandbox integration tests (Docker-only, requires root)
├── test_{module}.py         # one file per source module
└── live/                    # live LLM integration tests
    ├── conftest.py          # live fixtures (live_config, seeded_db, mock_noop_infra)
    ├── test_roles.py        # L1 — single brain function in isolation
    ├── test_flows.py        # L2 — 2-3 connected components
    ├── test_e2e.py          # L3 — full pipeline through _execute_plan
    ├── test_practical.py    # L4 — realistic user scenarios
    └── test_cli_live.py     # L5 — CLI lifecycle (GitHub, git)
```

## Test Suites

| Suite | Count | What it tests | Where to run | Secrets |
|---|---|---|---|---|
| Unit tests | ~970 | All code, fully mocked | Host | No |
| L1 role isolation | 8 | Single brain function + real LLM | Host or Docker | `KISO_LLM_API_KEY` |
| L2 partial flows | 4 | 2-3 connected components + real LLM | Host or Docker | `KISO_LLM_API_KEY` |
| L3 e2e | 4 | Full pipeline, **executes LLM-generated commands** | **Docker** | `KISO_LLM_API_KEY` |
| L4 practical | 7 | Realistic scenarios, **executes LLM-generated commands** | **Docker** | `KISO_LLM_API_KEY` |
| L5 CLI lifecycle | 5 | GitHub API + git clone | Host or Docker | No |
| Sandbox | 2 | Per-session Linux user isolation | Docker (root) | No |

**L3 and L4 run shell commands generated by the LLM** (e.g. `echo hello > file.txt`). Always run these inside Docker to isolate from the host.

## Setup

```bash
# 1. Copy the env template
cp .env.example .env

# 2. Add your OpenRouter API key (get one at https://openrouter.ai/keys)
#    KISO_LLM_API_KEY=sk-or-v1-...

# 3. Build the test image (once, or after code changes)
docker compose -f docker-compose.test.yml build
```

## Running Tests

### Unit tests — host (fast feedback)

```bash
uv run pytest tests/ -q                           # all unit tests
uv run pytest tests/test_brain.py -v               # single module
uv run pytest tests/ --cov=kiso --cov-fail-under=80 -q  # with coverage
```

No network, no secrets, no side effects.

### Live tests — Docker (safe)

```bash
# All live tests (L1-L5)
docker compose -f docker-compose.test.yml run --rm test-live

# Rebuild after code changes
docker compose -f docker-compose.test.yml build test-live && \
docker compose -f docker-compose.test.yml run --rm test-live
```

Reads `.env` for `KISO_LLM_API_KEY`. LLM-generated exec commands run inside the container, isolated from the host.

### Live tests on host (L1/L2/L5 only — no exec)

For fast iteration on tests that don't execute LLM-generated commands:

```bash
set -a; source .env; set +a

# L1 + L2 — only API calls, no exec
uv run pytest tests/live/test_roles.py tests/live/test_flows.py --llm-live -v

# L5 — only git/GitHub, no LLM
uv run pytest tests/live/test_cli_live.py --live-network -v
```

### Unit tests — Docker

```bash
docker compose -f docker-compose.test.yml run --rm test-unit
```

Same as running on host, but includes sandbox tests (container runs as root).

## Fixtures

Defined in `tests/conftest.py`:

- `test_config_path` — writes a valid `config.toml` to `tmp_path`, returns the `Path`
- `test_config` — calls `load_config(test_config_path)`
- `client` — async `httpx.AsyncClient` using `ASGITransport` with the app, config injected via `app.state`

Defined in `tests/live/conftest.py`:

- `live_config` — real OpenRouter config using `MODEL_DEFAULTS`
- `seeded_db` — fresh SQLite with a session row
- `mock_noop_infra` — patches filesystem/security/webhook, lets LLM calls through

All fixtures use `tmp_path` — tests never touch `~/.kiso/`.

## Conventions

- One test file per source module: `test_{module}.py`
- Test functions: `test_{behavior}` (e.g. `test_missing_tokens`)
- Error tests verify the message, not just that `SystemExit` was raised (use `capsys`)
- Config fixtures write to `tmp_path` — never read or mutate real `~/.kiso/`
- No sleeps, no network calls in unit tests, no flaky tests
- Live test assertions are intentionally loose — never exact text matching

## Sandbox Tests (Docker-only)

`tests/test_sandbox_docker.py` tests real per-session sandbox isolation: creating Linux users, `chown`/`chmod` on workspaces, and verifying that a sandboxed user cannot escape their workspace. Requires root.

On the host, these are automatically skipped via `@pytest.mark.skipif(os.getuid() != 0)`.

## CI (GitHub Actions)

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v4

      - name: Unit tests
        run: uv run pytest tests/ -q

      - name: Live tests (Docker)
        env:
          KISO_LLM_API_KEY: ${{ secrets.KISO_LLM_API_KEY }}
        run: |
          echo "KISO_LLM_API_KEY=$KISO_LLM_API_KEY" > .env
          docker compose -f docker-compose.test.yml run --rm test-live
```

## Details

For live test internals (flags, markers, timeouts, flakiness, troubleshooting), see [testing-live.md](testing-live.md).
